{
  "kind": "implementation_plan",
  "version": "1.0",
  "title": "Stabilize production initial load by preventing shell/storage/actor failures from crashing routing",
  "requirements": [
    {
      "id": "REQ-1",
      "summary": "Fix the production-only runtime error that triggers TanStack Router global error fallback on initial load and add crash-safe diagnostics to pinpoint any remaining failing module.",
      "acceptanceCriteria": [
        "In production, loading `/` renders the Home page content within `SiteLayout` and does not show the GlobalErrorFallbackPage.",
        "No uncaught exceptions occur during initial page load in the browser console (excluding expected network warnings).",
        "If an error still occurs, the console output includes enough context (error + stack, where available) to pinpoint the failing module/component without causing additional crashes."
      ],
      "file_operations": [
        {
          "path": "frontend/src/state/orderHistory.ts",
          "operation": "modify",
          "description": "Harden localStorage-backed order history state so any storage access (read/parse/write/remove/subscribe) is wrapped in try/catch and falls back to an in-memory empty history when storage is unavailable/corrupted (prevents production initial-load crashes from storage exceptions)."
        },
        {
          "path": "frontend/src/hooks/useOrderHistory.ts",
          "operation": "modify",
          "description": "Ensure the order history hook never throws during initial render: guard against storage failures, return stable defaults (empty list + safe booleans), and log a single, context-rich console error when recovery is triggered."
        },
        {
          "path": "frontend/src/components/error/GlobalErrorBoundary.tsx",
          "operation": "modify",
          "description": "Augment error logging to include normalized error message and stack when available (without assuming the thrown value is an Error), and ensure logging itself cannot throw; keep logs informative for production debugging."
        },
        {
          "path": "frontend/src/App.tsx",
          "operation": "modify",
          "description": "Wrap the RouterProvider with GlobalErrorBoundary so any non-router render-time crash is caught and logged with context; use GlobalErrorFallbackPage as the fallback renderer (helps prevent opaque production blank/fallback states and surfaces actionable diagnostics)."
        }
      ]
    },
    {
      "id": "REQ-2",
      "summary": "Make the global error fallback UI production-safe and impossible to crash, using browser-safe env checks and fully-guarded error detail rendering (English-only UI).",
      "acceptanceCriteria": [
        "GlobalErrorFallbackPage renders without throwing even when `error` is `undefined`, a string, or a non-Error object.",
        "No usage of `process.env.*` exists in runtime-executed frontend code paths for error fallback/handling.",
        "All visible fallback UI strings are in English."
      ],
      "file_operations": [
        {
          "path": "frontend/src/pages/GlobalErrorFallbackPage.tsx",
          "operation": "modify",
          "description": "Fully harden fallback rendering: normalize unknown thrown values into safe strings, guard all property access and optional rendering, avoid any non-browser-safe globals, and keep `import.meta.env` as the only environment check; ensure all user-facing strings remain English."
        },
        {
          "path": "frontend/src/utils/errors.ts",
          "operation": "modify",
          "description": "Add/adjust helper(s) to safely extract a debug-friendly string (and stack when present) from unknown thrown values without throwing, so GlobalErrorFallbackPage and GlobalErrorBoundary can display/log consistent context safely."
        }
      ]
    },
    {
      "id": "REQ-3",
      "summary": "Ensure SiteLayout and initial routing remain renderable even when actor creation, backend connectivity, or initial React Query calls fail by isolating non-critical UI and degrading gracefully.",
      "acceptanceCriteria": [
        "If the backend actor is not ready or backend calls fail, `SiteLayout` still renders header, footer, and the current route outlet.",
        "Admin link is shown only when ownership is positively confirmed; otherwise it stays hidden without errors.",
        "RecentOrdersMenu does not throw on load; when the actor is not ready it renders a disabled Orders button (or equivalent non-crashing UI)."
      ],
      "file_operations": [
        {
          "path": "frontend/src/components/error/SafeSection.tsx",
          "operation": "create",
          "description": "Create a small wrapper component that uses the existing GlobalErrorBoundary to isolate non-critical header UI sections (e.g., RecentOrdersMenu) and render a safe, non-throwing fallback UI when a child crashes."
        },
        {
          "path": "frontend/src/components/orders/RecentOrdersMenu.tsx",
          "operation": "modify",
          "description": "Make RecentOrdersMenu resilient to partial/failed dependencies: guard against unexpected undefined values, ensure mapping over history/details cannot throw, and avoid assuming query results are present; keep the existing disabled state when actor is not ready."
        },
        {
          "path": "frontend/src/components/layout/SiteLayout.tsx",
          "operation": "modify",
          "description": "Wrap RecentOrdersMenu with the new SafeSection so a failure in orders/history/query rendering cannot crash the entire app shell; keep admin link hidden unless ownership is positively confirmed; ensure header/footer/outlet always render even when non-critical queries fail."
        }
      ]
    }
  ]
}